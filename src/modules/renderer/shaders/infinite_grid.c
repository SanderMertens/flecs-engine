#include "shaders.h"
#include "../renderer.h"

static const char *kShaderSource =
    "struct Uniforms { vp : mat4x4<f32> }\n"
    "@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n"
    "struct VertexInput {\n"
    "  @location(0) pos : vec3<f32>,\n"
    "  @location(1) nrm : vec3<f32>,\n"
    "  @location(2) m0 : vec4<f32>,\n"
    "  @location(3) m1 : vec4<f32>,\n"
    "  @location(4) m2 : vec4<f32>,\n"
    "  @location(5) m3 : vec4<f32>,\n"
    "  @location(6) color : vec4<f32>,\n"
    "  @location(7) size : vec3<f32>\n"
    "};\n"
    "struct VertexOutput {\n"
    "  @builtin(position) pos : vec4<f32>,\n"
    "  @location(0) world_pos : vec3<f32>,\n"
    "  @location(1) color : vec4<f32>\n"
    "};\n"
    "@vertex fn vs_main(input : VertexInput) -> VertexOutput {\n"
    "  var out : VertexOutput;\n"
    "  let sm0 = input.m0 * input.size.x;\n"
    "  let sm1 = input.m1 * input.size.y;\n"
    "  let sm2 = input.m2 * input.size.z;\n"
    "  let model = mat4x4<f32>(sm0, sm1, sm2, input.m3);\n"
    "  let world_pos = model * vec4<f32>(input.pos, 1.0);\n"
    "  out.pos = uniforms.vp * world_pos;\n"
    "  out.world_pos = world_pos.xyz;\n"
    "  out.color = input.color;\n"
    "  return out;\n"
    "}\n"
    "fn line_factor(coord : vec2<f32>, spacing : f32) -> f32 {\n"
    "  let scaled = coord / spacing;\n"
    "  let pixel = max(fwidth(scaled), vec2<f32>(1e-5));\n"
    "  let grid = abs(fract(scaled - 0.5) - 0.5) / pixel;\n"
    "  let d = min(grid.x, grid.y);\n"
    "  return 1.0 - min(d, 1.0);\n"
    "}\n"
    "fn axis_factor(v : f32) -> f32 {\n"
    "  let w = fwidth(v) * 2.0 + 1e-5;\n"
    "  return 1.0 - smoothstep(0.0, w, abs(v));\n"
    "}\n"
    "@fragment fn fs_main(input : VertexOutput) -> @location(0) vec4<f32> {\n"
    "  let p = input.world_pos.xz;\n"
    "  let minor = line_factor(p, 1.0) * 0.28;\n"
    "  let major = line_factor(p, 10.0) * 0.42;\n"
    "  let axis_x = axis_factor(input.world_pos.x);\n"
    "  let axis_z = axis_factor(input.world_pos.z);\n"
    "  let grid = max(minor, major);\n"
    "  if (max(grid, max(axis_x, axis_z)) < 0.001) {\n"
    "    discard;\n"
    "  }\n"
    "  let view_dist = 1.0 / max(input.pos.w, 1e-5);\n"
    "  let fade = 1.0 - smoothstep(25.0, 90.0, view_dist);\n"
    "  if (fade < 0.001) {\n"
    "    discard;\n"
    "  }\n"
    "  var color = input.color.rgb * grid;\n"
    "  color = max(color, vec3<f32>(0.90, 0.25, 0.25) * axis_x);\n"
    "  color = max(color, vec3<f32>(0.25, 0.45, 0.95) * axis_z);\n"
    "  let bg = vec3<f32>(0.03, 0.03, 0.05);\n"
    "  color = mix(bg, color, fade);\n"
    "  return vec4<f32>(color, 1.0);\n"
    "}\n";

ecs_entity_t flecsEngineShader_infiniteGrid(
    ecs_world_t *world)
{
    return flecsEngineEnsureShader(world, "InfiniteGridShader",
        &(FlecsShader){
            .source = kShaderSource,
            .vertex_entry = "vs_main",
            .fragment_entry = "fs_main"
        });
}
